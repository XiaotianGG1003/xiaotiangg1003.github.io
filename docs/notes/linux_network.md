---
title: Linux 网络编程
---

# Linux 网络编程

## 网络模型和协议
* 采用分层模型实现网络通讯和数据交换，OSI网络模型分为七层，从上到下分别是应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。而目前广泛应用的是TCP/IP网络模型，从上到下分别是应用层、传输层、网路层、网络接口层。
* 一般在学习开发中，结合两者，采用五层网络模型，从上到下分别是应用层、传输层、网路层、数据链路层、物理层。本文基于五层模型进行学习理解。
![network_model](../assets/notes/linux/QQ20251202-104755.jpg)
![network_transport](../assets/notes/linux/QQ20251202-110742.jpg)

### 物理层
* 负责比特流的传输，把 0 和 1 真实地发送到电缆、光纤、无线电中

### 数据链路层
* 保证在同一局域网(同一链路)内的设备之间可靠传输数据帧。交换机、网卡工作在这一层
* 核心功能包括封装成帧(Frame)，差错检测，MAC寻址(ARP, RRAP)，主要协议有Ethernet(以太网)
* 以太网帧的一般格式如下,地址是指主机的MAC地址，数据部分不足46字节的补0
![Frame](../assets/notes/linux/QQ20251202-111613.jpg)

#### ARP地址解析协议
* 负责将IP数据报中的IP地址转换为MAC地址填入帧头，通过广播向当前网段的主机发送ARP请求(who has x.x.x.x? tell x.x.x.x)，收到请求的目的主机会响应请求(x.x.x.x is at MAC)
![arp](../assets/notes/linux/QQ20251202-101207.jpg)
* wireshark抓取的请求如图，前14个字节为以太网头，数据部分包含28字节，源地址，广播地址FF:FF:FF:FF:FF:FF(图中为定向arp request)，剩余18字节为PAD未显示

### 网络层
* 决定数据包从源到目的需要走哪条路，负责路由与转发，路由器，部分三层交换机工作在这一层
* 核心功能包括IP地址、路由选择、IP分片重组，主要协议有IP、ICMP、OSPF/RIP/BGP

#### IP
* IP地址采用**CIDR无分类域间路由选择**进行地址划分，采用网络前缀和主机号划分网段，特殊的IP地址如下

| IP网段 | 用途 |
| :----: | :----: |
| 0.0.0.0/8 | 作为源地址时表示本地主机；作为目的地址时，表示任意IP地址 |
| 10.0.0.0/8 | 局域网IP地址 |
| 172.16.0.0/12 | 局域网IP地址 |
| 192.168.0.0/16 | 局域网IP地址 |
| 127.0.0.0/8 | 本地回环地址 |
| 255.255.255.255/32 | 本地网络广播地址 |
* IP数据报格式如图
![ip1](../assets/notes/linux/QQ20251202-115907.jpg)
* 分片重组，由于IP数据报的长度限制65536字节，而数据链路层MTU为1500字节，因此IP数据包进入链路层时会进行分片，在网络中传输到目的主机，在网络层会进行重组
![ip2](../assets/notes/linux/QQ20251203-101047.jpg)
::: tip
因此一些协议会避免让数据报长度超过MTU，如TCP协议会在选项中设置最大段长度MSS为1460字节(MSS = MTU - TCP头 - IP头)
![ip3](../assets/notes/linux/QQ20251203-172136.jpg)
:::
* 通过路由表告诉设备收到的数据包该往哪个方向转发，实现跨网段、跨网络的通信。Linux使用`route -n`查看主机的路由表

#### NAT网络地址转换
NAT就是在离开内部网络的时候重写数据报的源地址为公网地址，进入内部网络的时候将目的地址从公网地址改成内网地址

#### ICMP网际控制报文协议
* ICMP（Internet Control Message Protocol）是一种网络层协议，主要用于传递控制消息与错误信息，用来让网络设备报告错误、测试连通性、控制网络行为。
* `ping`和`traceroute`（Windows下为`tracert`）

### 传输层
* 提供端到端通信，建立程序之间的“逻辑连接”，主要协议有TCP、UDP

#### TCP协议
* TCP是一个可靠、面向连接、字节流的协议
![tcp_head](../assets/notes/linux/QQ20251203-105450.jpg)

**序号：** 对于应用层的数据按字节进行编号，防止达到对端后发生乱序情况
**确认号：** 对已经发送的数据进行确认，表示确认号之前的数据已经到达，保证数据可靠到达
**数据偏移:** 表示TCP的报文头长度，(5 ~ 15) * 4(Base)= 20 ~ 60，TCP报文头至少20字节，最多60字节，TCP协议是一个可以扩展的协议

**标志位:**
* ***SYN:*** 建立连接请求，并设置序号
* ***ACK:*** 确认报文，设为`1`时，确认号有效
* ***FIN:*** 断开连接请求

**窗口：** 使用**滑动窗口机制**来实现**流量控制**和**拥塞控制**，发送方和接收方都维护一个滑动窗口，发送方窗口大小根据接收方窗口大小和当前网络状况动态调整，避免双方发送速率不一致或网络问题。

* TCP连接过程及状态变化
![tcp_status](../assets/notes/linux/QQ20251203-114728.jpg)

* 建立连接抓包如下
![tcp_package](../assets/notes/linux/QQ20251203-115048.jpg)

::: tip 
**Q1: 建立连接采用三次握手而不是两次的原因?** \
A1: 采用两次握手无法保证双方状态一致。 \
1.当客户端SYN请求未及时到达服务端时，客户端重发请求，服务器接受请求并建立连接，然后完成传输断开连接后，此时，第一次SYN请求延迟到达服务器时，服务器返回ACK并建立连接后，客户端并未建立连接。\
2.两次握手当服务端ACK返回丢失后，服务器不会重传ACK报文，会导致服务端已经建立连接，而客户端未建立连接。
![ack_2](../assets/notes/linux/QQ20251203-170803.jpg)

**Q2: 断开连接为什么采用四次挥手?** \
A2: TCP是全双工通信，但TCP的关闭是单向的，两端都必须独立的关闭自己的发送方向，因此需要两次FIN+ACK，特殊情况下，当发送方也没有数据发送时，会合并第二三次挥手。

**Q3: 服务端可以主动断开连接吗?** \
A3: 可以，服务端断开连接后进入TIME_WAIT状态，持续2MSL的超时时间，此时服务器资源被浪费，一般情况下不主动断开连接。\
主动关闭连接(发送FIN)的一方会进入TIME_WAIT状态，与客户端服务端无关。

**Q4: 为什么需要TIME_WAIT状态?** \
A4: 1. 防止最后一个ACK丢失，对端重传FIN报文情况。如直接关闭，此时无法接收到对端重传FIN报文，导致两边状态不一致。2MSL ≈ ACK(丢失) + 重传FIN。 \
2. 等待2MSL(Maximum Segment Lifetime)让网络中延迟的报文自然消失，避免污染新连接。
:::

#### UDP协议
* UDP是一个无连接、不可靠、面向报文、高效的协议。
* 无连接：通信前无需建立连接，意味着支持一对一、一对多通信。
* 不可靠：不保证消息一定送达、消息有序、消息不重复。
* 面向报文：对于应用层传来的数据视为完整的数据包，交给IP层分片，一次发送就是一条消息
* 头部信息如下
![udp](../assets/notes/linux/QQ20251203-205329.jpg)

### 应用层

## socket编程




